/**
 * @file cc2t.c
 * @brief TAC inspection and analysis tool for STCC1 compiler
 * @author Thomas Boos (tboos70@gmail.com)
 * @version 0.1
 * @date 2025-07-16
 * @copyright Copyright (c) 2024-2025 Thomas Boos
 *
 * @details CC2T is a TAC inspection tool that reads TAC files generated by CC2:
 * - Displays human-readable TAC instructions
 * - Shows TAC statistics and analysis
 * - Provides detailed operand usage information
 * - Analyzes control flow and basic blocks
 * - Similar to cc0t (token inspection) and cc1t (AST inspection)
 *
 * Usage: cc2t <tacfile> <symfile> [sstorefile]
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#include "../ir/tac_store.h"
#include "../ir/tac_printer.h"
#include "../ir/tac_types.h"
#include "../storage/sstore.h"
#include "../storage/symtab.h"

/**
 * @brief Display usage information
 */
static void show_usage(const char* program_name) {
    printf("Usage: %s <tacfile> <symfile> [sstorefile]\n", program_name);
    printf("\n");
    printf("Arguments:\n");
    printf("  tacfile     - TAC instruction file to analyze\n");
    printf("  symfile     - Symbol table file for variable name resolution\n");
    printf("  sstorefile  - String store file (optional)\n");
    printf("\n");
    printf("TAC Inspection Tool for STCC1 Compiler\n");
    printf("Displays Three-Address Code instructions and analysis\n");
    printf("\n");
    printf("Arguments:\n");
    printf("  tacfile    - TAC binary file (generated by cc2)\n");
    printf("\n");
    printf("Output:\n");
    printf("  - Human-readable TAC instructions\n");
    printf("  - Instruction type distribution\n");
    printf("  - Operand usage analysis\n");
    printf("  - Memory usage statistics\n");
    printf("  - Control flow information\n");
}

/**
 * @brief Display TAC file header information
 */
static void show_tac_header(const char* filename) {
    printf("=== TAC File Analysis ===\n");
    printf("File: %s\n", filename);

    // Get file size
    FILE* fp = fopen(filename, "rb");
    if (fp) {
        fseek(fp, 0, SEEK_END);
        long file_size = ftell(fp);
        fclose(fp);

        printf("Size: %ld bytes\n", file_size);
        printf("Instructions: %ld\n", file_size / sizeof(TACInstruction));
    }
    printf("\n");
}

/**
 * @brief Display detailed instruction analysis
 */
static void show_detailed_analysis(void) {
    printf("\n=== Detailed TAC Analysis ===\n");

    // Get total instruction count
    TACIdx_t total_instructions = tacstore_getidx();

    if (total_instructions == 0) {
        printf("No TAC instructions found.\n");
        return;
    }

    printf("Analyzing %u instructions...\n\n", total_instructions);

    // Analyze instruction patterns
    int label_count = 0;
    int jump_count = 0;
    int arithmetic_count = 0;
    int assignment_count = 0;
    int function_count = 0;

    for (TACIdx_t i = 1; i <= total_instructions; i++) {
        TACInstruction instr = tacstore_get(i);

        switch (instr.opcode) {
            case TAC_LABEL:
                label_count++;
                break;

            case TAC_GOTO:
            case TAC_IF_FALSE:
            case TAC_IF_TRUE:
                jump_count++;
                break;

            case TAC_ADD:
            case TAC_SUB:
            case TAC_MUL:
            case TAC_DIV:
            case TAC_MOD:
            case TAC_AND:
            case TAC_OR:
            case TAC_XOR:
            case TAC_SHL:
            case TAC_SHR:
                arithmetic_count++;
                break;

            case TAC_ASSIGN:
            case TAC_LOAD:
            case TAC_STORE:
                assignment_count++;
                break;

            case TAC_CALL:
            case TAC_PARAM:
            case TAC_RETURN:
            case TAC_RETURN_VOID:
                function_count++;
                break;

            default:
                break;
        }
    }

    printf("Instruction Categories:\n");
    printf("  Labels:     %d\n", label_count);
    printf("  Jumps:      %d\n", jump_count);
    printf("  Arithmetic: %d\n", arithmetic_count);
    printf("  Assignment: %d\n", assignment_count);
    printf("  Functions:  %d\n", function_count);
    printf("  Other:      %d\n", total_instructions - label_count - jump_count -
           arithmetic_count - assignment_count - function_count);
}

/**
 * @brief Analyze control flow patterns
 */
static void analyze_control_flow(void) {
    printf("\n=== Control Flow Analysis ===\n");

    TACIdx_t total_instructions = tacstore_getidx();

    if (total_instructions == 0) {
        printf("No instructions to analyze.\n");
        return;
    }

    int basic_blocks = 0;
    int branches = 0;
    bool in_block = false;

    for (TACIdx_t i = 1; i <= total_instructions; i++) {
        TACInstruction instr = tacstore_get(i);

        // Count basic block starts (labels or first instruction)
        if (instr.opcode == TAC_LABEL || (!in_block && i == 1)) {
            basic_blocks++;
            in_block = true;
        }

        // Count branches
        if (instr.opcode == TAC_GOTO || instr.opcode == TAC_IF_FALSE ||
            instr.opcode == TAC_IF_TRUE || instr.opcode == TAC_RETURN ||
            instr.opcode == TAC_RETURN_VOID) {
            branches++;
            in_block = false;
        }
    }

    printf("Basic blocks: %d (estimated)\n", basic_blocks);
    printf("Branches:     %d\n", branches);

    if (basic_blocks > 0) {
        printf("Average instructions per block: %.1f\n",
               (float)total_instructions / basic_blocks);
    }
}

/**
 * @brief Display optimization flags summary
 */
static void show_optimization_flags(void) {
    printf("\n=== Optimization Flags Analysis ===\n");

    TACIdx_t total_instructions = tacstore_getidx();

    if (total_instructions == 0) {
        printf("No instructions to analyze.\n");
        return;
    }

    int dead_code = 0;
    int const_fold = 0;
    int cse = 0;
    int copy_prop = 0;
    int optimized = 0;

    for (TACIdx_t i = 1; i <= total_instructions; i++) {
        TACInstruction instr = tacstore_get(i);

        if (instr.flags & TAC_FLAG_DEAD_CODE) dead_code++;
        if (instr.flags & TAC_FLAG_CONST_FOLD) const_fold++;
        if (instr.flags & TAC_FLAG_CSE) cse++;
        if (instr.flags & TAC_FLAG_COPY_PROP) copy_prop++;
        if (instr.flags & TAC_FLAG_OPTIMIZED) optimized++;
    }

    printf("Dead code candidates:      %d\n", dead_code);
    printf("Constant folding applied:  %d\n", const_fold);
    printf("CSE opportunities:         %d\n", cse);
    printf("Copy propagation applied:  %d\n", copy_prop);
    printf("Optimization complete:     %d\n", optimized);

    if (total_instructions > 0) {
        printf("Optimization coverage:     %.1f%%\n",
               (float)optimized * 100.0f / total_instructions);
    }
}

/**
 * @brief Reconstruct function table from symbol table for proper label names
 */
static void reconstruct_function_table(void) {
    static TACPrinterFunctionTable printer_table;
    printer_table.count = 0;
    
    // First, collect all function symbols
    SymIdx_t sym_count = symtab_get_count();
    struct {
        const char* name;
        uint16_t symbol_idx;
    } functions[32];
    uint32_t func_count = 0;
    
    for (SymIdx_t i = 1; i <= sym_count && func_count < 32; i++) {
        SymTabEntry entry = symtab_get(i);
        
        // Look for function symbols
        if (entry.type == SYM_FUNCTION && entry.name > 0) {
            const char* func_name = sstore_get(entry.name);
            if (func_name && strlen(func_name) > 0) {
                functions[func_count].name = func_name;
                functions[func_count].symbol_idx = i;
                func_count++;
            }
        }
    }
    
    // Now scan TAC instructions to find which labels correspond to functions
    // For now, assign labels sequentially - this is a limitation we'll fix later
    for (uint32_t i = 0; i < func_count; i++) {
        #pragma GCC diagnostic push
        #pragma GCC diagnostic ignored "-Wcast-qual"
        printer_table.function_names[i] = (char*)functions[i].name;
        #pragma GCC diagnostic pop
        
        // Assign label IDs: main gets label 1, other functions get sequential IDs
        if (strcmp(functions[i].name, "main") == 0) {
            printer_table.label_ids[i] = 1;  // main is typically the first label
        } else {
            printer_table.label_ids[i] = i + 1;  // Sequential assignment
        }
        printer_table.count++;
    }
    
    if (printer_table.count > 0) {
        tac_printer_set_function_table(&printer_table);
        printf("✓ Reconstructed function table with %u functions\n", printer_table.count);
    }
}

/**
 * @brief Main function for CC2T TAC inspection tool
 */
int main(int argc, char* argv[]) {
    if (argc < 3 || argc > 4) {
        show_usage(argv[0]);
        return 1;
    }

    const char* tac_file = argv[1];
    const char* sym_file = argv[2];
    const char* sstore_file = (argc == 4) ? argv[3] : NULL;

    printf("=== STCC1 TAC Inspection Tool (CC2T) ===\n");
    printf("TAC file: %s\n", tac_file);
    printf("Symbol table file: %s\n", sym_file);
    if (sstore_file) {
        printf("String store file: %s\n", sstore_file);
    }
    printf("\n");

    // Load string store if provided
    if (sstore_file) {
        if (sstore_open(sstore_file) != 0) {
            fprintf(stderr, "Error: Cannot load string store %s\n", sstore_file);
            return 1;
        }
        printf("✓ String store loaded successfully\n");
    }

    // Load symbol table
    if (symtab_open(sym_file) != 0) {
        fprintf(stderr, "Error: Cannot load symbol table %s\n", sym_file);
        return 1;
    }
    printf("✓ Symbol table loaded successfully\n\n");

    // Show file information
    show_tac_header(tac_file);

    // Open TAC store for reading
    if (tacstore_open(tac_file) != 1) {
        fprintf(stderr, "Error: Cannot open TAC file %s\n", tac_file);
        return 1;
    }

    // Reconstruct function table from symbol table for proper label names
    reconstruct_function_table();

    // Display all TAC instructions
    printf("=== TAC Instructions ===\n");
    tac_print_all_instructions();

    // Display standard statistics
    printf("\n");
    tac_print_statistics();

    // Display operand usage analysis
    printf("\n");
    tac_analyze_operand_usage();

    // Show detailed analysis
    show_detailed_analysis();

    // Analyze control flow
    analyze_control_flow();

    // Show optimization flags
    show_optimization_flags();

    // Store validation
    printf("\n=== TAC Store Validation ===\n");
    if (tacstore_validate()) {
        printf("✓ TAC store structure is valid\n");
    } else {
        printf("⚠ TAC store validation warnings detected\n");
    }

    // Display store statistics
    printf("\n");
    tacstore_print_stats();

    printf("\n=== CC2T Analysis Complete ===\n");

    // Clean up
    tacstore_close();

    return 0;
}
