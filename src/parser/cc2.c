/**
 * @file cc2.c
 * @brief TAC Generation Compiler Pass - STCC1 Compiler
 * @author Thomas Boos (tboos70@gmail.com)
 * @version 0.1
 * @date 2025-07-16
 * @copyright Copyright (c) 2024-2025 Thomas Boos
 *
 * @details CC2 is the TAC generation pass that processes the output from CC1:
 * - Reads AST from astore (generated by cc1)
 * - Reads symbol table from symtab (generated by cc1)
 * - Reads string store from sstore (generated by cc0)
 * - Reads token store from tstore (generated by cc0)
 * - Generates Three-Address Code (TAC) instructions
 * - Outputs TAC in human-readable format and binary format
 *
 * Pipeline: cc0 → cc1 → cc2
 * - cc0: C source → strings + tokens
 * - cc1: strings + tokens → AST + symbols  
 * - cc2: strings + tokens + AST + symbols → TAC
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../storage/sstore.h"
#include "../storage/tstore.h"
#include "../storage/astore.h"
#include "../storage/symtab.h"
#include "../ir/tac_builder.h"
#include "../ir/tac_printer.h"
#include "../utils/hmapbuf.h"
#include "../error/error_core.h"

/**
 * @brief CC2 compiler state
 */
typedef struct CC2State {
    TACBuilder tac_builder;
    char* output_filename;
    char* tac_filename;
    int verbose;
    int errors;
    int warnings;
} CC2State;

static CC2State cc2_state = {0};

/**
 * @brief Initialize CC2 compiler pass
 * 
 * @param tac_filename Output filename for TAC binary format
 * @param output_filename Output filename for human-readable TAC
 * @return 0 on success, -1 on error
 */
static int cc2_init(const char* tac_filename, const char* output_filename) {
    memset(&cc2_state, 0, sizeof(CC2State));
    
    // Initialize TAC builder
    if (!tac_builder_init(&cc2_state.tac_builder, tac_filename)) {
        fprintf(stderr, "Error: Cannot initialize TAC builder\n");
        return -1;
    }
    
    // Store output filenames
    cc2_state.tac_filename = strdup(tac_filename);
    cc2_state.output_filename = strdup(output_filename);
    cc2_state.verbose = 1;
    
    return 0;
}

/**
 * @brief Clean up CC2 resources
 */
static void cc2_cleanup(void) {
    tac_builder_cleanup(&cc2_state.tac_builder);
    
    if (cc2_state.tac_filename) {
        free(cc2_state.tac_filename);
    }
    if (cc2_state.output_filename) {
        free(cc2_state.output_filename);
    }
    
    memset(&cc2_state, 0, sizeof(CC2State));
}


/**
 * @brief Process AST node recursively
 * 
 * @param node_idx AST node index to process
 * @return 0 on success, -1 on error
 */


/**
 * @brief Traverse all AST nodes systematically
 * 
 * @return Number of nodes processed
 */
static int cc2_process_all_ast_nodes(void) {
    int node_count = 0;
    
    if (cc2_state.verbose) {
        printf("Traversing AST nodes systematically...\n");
    }
    
    printf("DEBUG: Starting AST traversal...\n");
    
    // Find the program root (should be AST_PROGRAM type)
    ASTNodeIdx_t program_root = 0;
    for (ASTNodeIdx_t idx = 1; idx <= 100; idx++) {
        ASTNode node = astore_get(idx);
        printf("DEBUG: Node %u has type %d\n", idx, node.type);
        
        if (node.type == AST_PROGRAM) {
            program_root = idx;
            printf("DEBUG: Found program root at node %u\n", idx);
            break;
        }
    }
    
    if (program_root != 0) {
        printf("DEBUG: Processing from program root\n");
        TACOperand result = tac_build_from_ast(&cc2_state.tac_builder, program_root);
        (void)result;
        node_count = 1;
    } else {
        printf("DEBUG: No program root found, processing all valid nodes\n");
        // Fallback: process all valid nodes
        for (ASTNodeIdx_t idx = 1; idx <= 100; idx++) {
            ASTNode node = astore_get(idx);
            
            if (node.type != AST_FREE) {
                printf("DEBUG: Processing valid node %u (type %d)\n", idx, node.type);
                TACOperand result = tac_build_from_ast(&cc2_state.tac_builder, idx);
                (void)result;
                node_count++;
            }
        }
    }
    
    printf("DEBUG: Total nodes processed: %d\n", node_count);
    return node_count;
}

/**
 * @brief Process the entire program and generate TAC
 * 
 * @return 0 on success, -1 on error
 */
static int cc2_process_program(void) {
    if (cc2_state.verbose) {
        printf("=== TAC Generation Pass ===\n");
    }
    
    // Process the AST systematically
    int node_count = cc2_process_all_ast_nodes();
    
    if (cc2_state.verbose) {
        printf("Processed %d AST nodes\n", node_count);
    }
    
    return 0;
}

/**
 * @brief Generate output files
 * 
 * @return 0 on success, -1 on error
 */
static int cc2_generate_output(void) {
    if (cc2_state.verbose) {
        printf("\n=== Generating TAC Output ===\n");
    }
    
    // Print statistics
    tac_print_statistics();
    
    // Generate human-readable TAC file
    if (cc2_state.output_filename) {
        if (cc2_state.verbose) {
            printf("Writing human-readable TAC to: %s\n", cc2_state.output_filename);
        }
        
        tac_write_to_file(cc2_state.output_filename);
    }
    
    // TAC binary format is already written by tac_builder
    if (cc2_state.verbose) {
        printf("TAC binary format written to: %s\n", cc2_state.tac_filename);
    }
    
    return 0;
}

/**
 * @brief Main compiler function for CC2
 * 
 * @param argc Number of command line arguments
 * @param argv Command line arguments: cc2 <sstorfile> <tokenfile> <astfile> <symfile> <tacfile> [output.tac]
 * @return 0 on success, non-zero on error
 */
int main(int argc, char *argv[]) {
    // Parse command line arguments
    if (argc < 6 || argc > 7) {
        fprintf(stderr, "Usage: %s <sstorfile> <tokenfile> <astfile> <symfile> <tacfile> [output.tac]\n", argv[0]);
        fprintf(stderr, "\n");
        fprintf(stderr, "  sstorfile  - String store file (from cc0)\n");
        fprintf(stderr, "  tokenfile  - Token store file (from cc0)\n");  
        fprintf(stderr, "  astfile    - AST store file (from cc1)\n");
        fprintf(stderr, "  symfile    - Symbol table file (from cc1)\n");
        fprintf(stderr, "  tacfile    - TAC binary output file\n");
        fprintf(stderr, "  output.tac - Human-readable TAC output (optional)\n");
        return 1;
    }
    
    const char* sstore_file = argv[1];
    const char* token_file = argv[2];
    const char* ast_file = argv[3];
    const char* sym_file = argv[4];
    const char* tac_file = argv[5];
    const char* output_file = (argc >= 7) ? argv[6] : NULL;
    
    printf("=== STCC1 Compiler - TAC Generation Pass (CC2) ===\n");
    printf("Input files:\n");
    printf("  String store: %s\n", sstore_file);
    printf("  Token store:  %s\n", token_file);
    printf("  AST store:    %s\n", ast_file);
    printf("  Symbol table: %s\n", sym_file);
    printf("Output files:\n");
    printf("  TAC binary:   %s\n", tac_file);
    if (output_file) {
        printf("  TAC text:     %s\n", output_file);
    }
    printf("\n");
    
    // Initialize storage systems (open existing files from cc0/cc1)
    if (sstore_open(sstore_file) != 0) {
        fprintf(stderr, "Error: Cannot open string store file %s\n", sstore_file);
        return 1;
    }
    
    if (tstore_open(token_file) != 0) {
        fprintf(stderr, "Error: Cannot open token file %s\n", token_file);
        sstore_close();
        return 1;
    }
    
    if (astore_open(ast_file) != 0) {
        fprintf(stderr, "Error: Cannot open AST file %s\n", ast_file);
        tstore_close();
        sstore_close();
        return 1;
    }
    
    if (symtab_open(sym_file) != 0) {
        fprintf(stderr, "Error: Cannot open symbol table file %s\n", sym_file);
        astore_close();
        tstore_close();
        sstore_close();
        return 1;
    }
    
    // Initialize CC2 compiler pass
    if (cc2_init(tac_file, output_file) != 0) {
        fprintf(stderr, "Error: Cannot initialize CC2 compiler pass\n");
        symtab_close();
        astore_close();
        tstore_close();
        sstore_close();
        return 1;
    }
    
    // Process the program and generate TAC
    int result = cc2_process_program();
    
    if (result == 0) {
        // Generate output files
        result = cc2_generate_output();
    }
    
    // Report results
    printf("\n=== CC2 Compilation Results ===\n");
    printf("Errors:   %d\n", cc2_state.errors);
    printf("Warnings: %d\n", cc2_state.warnings);
    
    if (result == 0 && cc2_state.errors == 0) {
        printf("TAC generation completed successfully!\n");
    } else {
        printf("TAC generation completed with %s\n", 
               cc2_state.errors > 0 ? "errors" : "warnings");
    }
    
    // Clean up
    cc2_cleanup();
    symtab_close();
    astore_close();
    tstore_close();
    sstore_close();
    
    return (cc2_state.errors > 0) ? 1 : 0;
}
