/**
 * @file cc2.c
 * @brief TAC Generation Compiler Pass - STCC1 Compiler
 * @author Thomas Boos (tboos70@gmail.com)
 * @version 0.1
 * @date 2025-07-16
 * @copyright Copyright (c) 2024-2025 Thomas Boos
 *
 * @details CC2 is the TAC generation pass that processes the output from CC1:
 * - Reads AST from astore (generated by cc1)
 * - Reads symbol table from symtab (generated by cc1)
 * - Reads string store from sstore (generated by cc0)
 * - Reads token store from tstore (generated by cc0)
 * - Generates Three-Address Code (TAC) instructions
 * - Outputs TAC in human-readable format and binary format
 *
 * Pipeline: cc0 → cc1 → cc2
 * - cc0: C source → strings + tokens
 * - cc1: strings + tokens → AST + symbols  
 * - cc2: strings + tokens + AST + symbols → TAC
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../storage/sstore.h"
#include "../storage/tstore.h"
#include "../storage/astore.h"
#include "../storage/symtab.h"
#include "../ir/tac_builder.h"
#include "../ir/tac_printer.h"
#include "../utils/hmapbuf.h"
#include "../error/error_core.h"

/**
 * @brief CC2 compiler state
 */
typedef struct CC2State {
    TACBuilder tac_builder;
    char* output_filename;
    char* tac_filename;
    int verbose;
    int errors;
    int warnings;
} CC2State;

static CC2State cc2_state = {0};

/**
 * @brief Initialize CC2 compiler pass
 * 
 * @param tac_filename Output filename for TAC binary format
 * @param output_filename Output filename for human-readable TAC
 * @return 0 on success, -1 on error
 */
static int cc2_init(const char* tac_filename, const char* output_filename) {
    memset(&cc2_state, 0, sizeof(CC2State));
    
    // Initialize TAC builder
    if (!tac_builder_init(&cc2_state.tac_builder, tac_filename)) {
        fprintf(stderr, "Error: Cannot initialize TAC builder\n");
        return -1;
    }
    
    // Store output filenames
    cc2_state.tac_filename = strdup(tac_filename);
    cc2_state.output_filename = strdup(output_filename);
    cc2_state.verbose = 1;
    
    return 0;
}

/**
 * @brief Clean up CC2 resources
 */
static void cc2_cleanup(void) {
    tac_builder_cleanup(&cc2_state.tac_builder);
    
    if (cc2_state.tac_filename) {
        free(cc2_state.tac_filename);
    }
    if (cc2_state.output_filename) {
        free(cc2_state.output_filename);
    }
    
    memset(&cc2_state, 0, sizeof(CC2State));
}

/**
 * @brief Process a function from the AST and generate TAC
 * 
 * @param function_node AST node representing the function
 * @return 0 on success, -1 on error
 */
static int cc2_process_function(ASTNodeIdx_t function_node) {
    if (function_node == 0) {
        return 0; // Empty/invalid function
    }
    
    HBNode* node = HBGet(function_node, HBMODE_AST);
    if (!node) {
        fprintf(stderr, "Warning: Cannot access function AST node %u\n", function_node);
        cc2_state.warnings++;
        return 0;
    }
    
    // Generate TAC for function
    if (cc2_state.verbose) {
        printf("Generating TAC for function at AST node %u\n", function_node);
    }
    
    TACOperand result = tac_build_from_ast(&cc2_state.tac_builder, function_node);
    if (result.type == TAC_OP_NONE) {
        fprintf(stderr, "Warning: No TAC generated for function node %u\n", function_node);
        cc2_state.warnings++;
    }
    
    return 0;
}

/**
 * @brief Process all functions in the symbol table
 * 
 * @return Number of functions processed
 */
static int cc2_process_all_functions(void) {
    int function_count = 0;
    
    if (cc2_state.verbose) {
        printf("Scanning symbol table for functions...\n");
    }
    
    // Iterate through symbol table to find functions
    // Note: This is a simplified approach - a full implementation would
    // traverse the AST more systematically
    for (SymIdx_t sym_idx = 1; sym_idx < 1000; sym_idx++) {
        SymTabEntry sym = symtab_get(sym_idx);
        if (sym.type == SYM_FREE) continue;
        
        // Check if this is a function symbol
        if (sym.type == SYM_FUNCTION) {
            if (cc2_state.verbose) {
                printf("Found function symbol %u\n", sym_idx);
            }
            
            // Generate TAC for this function
            // In a full implementation, we'd need to find the corresponding AST node
            // For now, we'll generate a simple function entry
            TACOperand func_label = tac_new_label(&cc2_state.tac_builder);
            tac_emit_label(&cc2_state.tac_builder, func_label.data.label.offset);
            
            function_count++;
        }
    }
    
    return function_count;
}

/**
 * @brief Process the entire program and generate TAC
 * 
 * @return 0 on success, -1 on error
 */
static int cc2_process_program(void) {
    if (cc2_state.verbose) {
        printf("=== TAC Generation Pass ===\n");
    }
    
    // Process global scope and functions
    int function_count = cc2_process_all_functions();
    
    if (cc2_state.verbose) {
        printf("Processed %d functions\n", function_count);
    }
    
    // For demonstration, let's also process the root AST node
    // In a real compiler, we'd traverse the AST systematically
    ASTNodeIdx_t root_node = 1; // Assume root is at index 1
    HBNode* root = HBGet(root_node, HBMODE_AST);
    if (root) {
        if (cc2_state.verbose) {
            printf("Processing program root AST node\n");
        }
        cc2_process_function(root_node);
    }
    
    return 0;
}

/**
 * @brief Generate output files
 * 
 * @return 0 on success, -1 on error
 */
static int cc2_generate_output(void) {
    if (cc2_state.verbose) {
        printf("\n=== Generating TAC Output ===\n");
    }
    
    // Print statistics
    tac_print_statistics();
    
    // Generate human-readable TAC file
    if (cc2_state.output_filename) {
        if (cc2_state.verbose) {
            printf("Writing human-readable TAC to: %s\n", cc2_state.output_filename);
        }
        
        tac_write_to_file(cc2_state.output_filename);
    }
    
    // TAC binary format is already written by tac_builder
    if (cc2_state.verbose) {
        printf("TAC binary format written to: %s\n", cc2_state.tac_filename);
    }
    
    return 0;
}

/**
 * @brief Main compiler function for CC2
 * 
 * @param argc Number of command line arguments
 * @param argv Command line arguments: cc2 <sstorfile> <tokenfile> <astfile> <symfile> <tacfile> [output.tac]
 * @return 0 on success, non-zero on error
 */
int main(int argc, char *argv[]) {
    // Parse command line arguments
    if (argc < 6 || argc > 7) {
        fprintf(stderr, "Usage: %s <sstorfile> <tokenfile> <astfile> <symfile> <tacfile> [output.tac]\n", argv[0]);
        fprintf(stderr, "\n");
        fprintf(stderr, "  sstorfile  - String store file (from cc0)\n");
        fprintf(stderr, "  tokenfile  - Token store file (from cc0)\n");  
        fprintf(stderr, "  astfile    - AST store file (from cc1)\n");
        fprintf(stderr, "  symfile    - Symbol table file (from cc1)\n");
        fprintf(stderr, "  tacfile    - TAC binary output file\n");
        fprintf(stderr, "  output.tac - Human-readable TAC output (optional)\n");
        return 1;
    }
    
    const char* sstore_file = argv[1];
    const char* token_file = argv[2];
    const char* ast_file = argv[3];
    const char* sym_file = argv[4];
    const char* tac_file = argv[5];
    const char* output_file = (argc >= 7) ? argv[6] : NULL;
    
    printf("=== STCC1 Compiler - TAC Generation Pass (CC2) ===\n");
    printf("Input files:\n");
    printf("  String store: %s\n", sstore_file);
    printf("  Token store:  %s\n", token_file);
    printf("  AST store:    %s\n", ast_file);
    printf("  Symbol table: %s\n", sym_file);
    printf("Output files:\n");
    printf("  TAC binary:   %s\n", tac_file);
    if (output_file) {
        printf("  TAC text:     %s\n", output_file);
    }
    printf("\n");
    
    // Initialize storage systems (open existing files from cc0/cc1)
    if (sstore_open(sstore_file) != 0) {
        fprintf(stderr, "Error: Cannot open string store file %s\n", sstore_file);
        return 1;
    }
    
    if (tstore_open(token_file) != 0) {
        fprintf(stderr, "Error: Cannot open token file %s\n", token_file);
        sstore_close();
        return 1;
    }
    
    if (astore_open(ast_file) != 0) {
        fprintf(stderr, "Error: Cannot open AST file %s\n", ast_file);
        tstore_close();
        sstore_close();
        return 1;
    }
    
    if (symtab_open(sym_file) != 0) {
        fprintf(stderr, "Error: Cannot open symbol table file %s\n", sym_file);
        astore_close();
        tstore_close();
        sstore_close();
        return 1;
    }
    
    // Initialize CC2 compiler pass
    if (cc2_init(tac_file, output_file) != 0) {
        fprintf(stderr, "Error: Cannot initialize CC2 compiler pass\n");
        symtab_close();
        astore_close();
        tstore_close();
        sstore_close();
        return 1;
    }
    
    // Process the program and generate TAC
    int result = cc2_process_program();
    
    if (result == 0) {
        // Generate output files
        result = cc2_generate_output();
    }
    
    // Report results
    printf("\n=== CC2 Compilation Results ===\n");
    printf("Errors:   %d\n", cc2_state.errors);
    printf("Warnings: %d\n", cc2_state.warnings);
    
    if (result == 0 && cc2_state.errors == 0) {
        printf("TAC generation completed successfully!\n");
    } else {
        printf("TAC generation completed with %s\n", 
               cc2_state.errors > 0 ? "errors" : "warnings");
    }
    
    // Clean up
    cc2_cleanup();
    symtab_close();
    astore_close();
    tstore_close();
    sstore_close();
    
    return (cc2_state.errors > 0) ? 1 : 0;
}
